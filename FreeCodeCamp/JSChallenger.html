<script>
/****** fundamentals  ***/
// Write a function that takes a value as argument. Return the type of the value.
 
function myFunction(a) {
   return typeof a;
}
/*
myFunction(1)
Expected
'number'
myFunction(false)
Expected
'boolean'
myFunction({})
Expected
'object'
myFunction(null)
Expected
'object'
myFunction('string')
Expected
'string'
myFunction(['array'])
Expected
'object'
*/ 



// Write a function that takes a string (a) and a number (n) as argument. Return the nth character of 'a'.
function myFunction(a, n){
return a.charAt(n-1);
}

// also 
function myFunction(a, n) {
   return a[n - 1];
}

// myFunction('abcd',1)
// Expected
// 'a'
// myFunction('zyxbwpl',5)
// Expected
// 'w'
// myFunction('gfedcba',3)
// Expected
// 'e'

// Write a function that takes a string (a) as argument. Remove the first 3 characters of a. Return the result
function myFunction(a) {
   return a.slice(3);
}
/*
myFunction('abcdefg')
Expected
'defg'
myFunction('1234')
Expected
'4'
myFunction('fgedcba')
Expected
'dcba'
*/ 


// Write a function that takes a string as argument. Extract the last 3 characters from the string. Return the result
function myFunction(str) {
   return str.slice(-3);
}
/*
myFunction('abcdefg')
Expected
'efg'
myFunction('1234')
Expected
'234'
myFunction('fgedcba')
Expected
'cba'
*/ 

// Write a function that takes a string (a) as argument. Get the first 3 characters of a. Return the result
function myFunction(a) {
   return a.slice(0, 3);
}
/*
myFunction('abcdefg')
Expected
'abc'
myFunction('1234')
Expected
'123'
myFunction('fgedcba')
Expected
'fge'
*/ 

// Write a function that takes a string as argument. The string contains the substring 'is'. Return the index of 'is'.

function myFunction(a) {
   return a.indexOf('is');
}
/*
myFunction("praise")
Expected
3
myFunction("risky")
Expected
1
myFunction("paris")
Expected
3
*/ 


// Write a function that takes a string (a) as argument. Extract the first half a. Return the result
function myFunction(a){
 return a.slice(0, a.length / 2);
}
/*
myFunction('abcdefgh')
Expected
'abcd'
myFunction('1234')
Expected
'12'
myFunction('gedcba')
Expected
'ged'
*/ 

// Write a function that takes a string (a) as argument. Remove the last 3 characters of a. Return the result
function myFunction(a) {
   return a.slice(0, -3);
}
/*myFunction('abcdefg')
Expected
'abcd'
myFunction('1234')
Expected
'1'
myFunction('fgedcba')
Expected
'fged'
*/ 

// Write a function that takes two numbers (a and b) as argument. Return b percent of a
function myFunction(a, b) {
  return b / 100 * a
}
/*myFunction(100,50)
Expected
50
myFunction(10,1)
Expected
0.1
myFunction(500,25)
Expected
125
*/ 

// Write a function that takes 6 values (a,b,c,d,e,f) as arguments. Sum a and b. Then substract by c. Then multiply by d and divide by e. Finally raise to the power of f and return the result. Tipp: mind the order.
function myFunction(a, b, c, d, e, f) {
   return (((a + b - c) * d) / e) ** f;
}
/*
myFunction(6,5,4,3,2,1)
Expected
10.5
myFunction(6,2,1,4,2,3)
Expected
2744
myFunction(2,3,6,4,2,3)
Expected
-8
 */ 

//  Write a function that takes two strings (a and b) as arguments. If a contains b, append b to the beginning of a. If not, append it to the end. Return the concatenation
function myFunction(a, b){
  return (a.includes(b) ? b.concat(a) : a.concat(b));
}
// also 
function myFunction(a, b) {
    // returns -1 if the value is not found
  return a.indexOf(b) === -1 ? a + b : b + a
}
/*
myFunction('cheese', 'cake')
Expected
'cheesecake'
myFunction('lips', 's')
Expected
'slips'
myFunction('Java', 'script')
Expected
'Javascript'
myFunction(' think, therefore I am', 'I')
Expected
'I think, therefore I am'
*/ 


// Write a function that takes two strings (a and b) as arguments. Return the number of times a occurs in b.
function myFunction (a, b){
return b.split(a).length-1
}

/*
myFunction('m', 'how many times does the character occur in this sentence?')
Expected
2
myFunction('h', 'how many times does the character occur in this sentence?')
Expected
4
myFunction('?', 'how many times does the character occur in this sentence?')
Expected
1
myFunction('z', 'how many times does the character occur in this sentence?')
Expected
0
*/ 


// Write a function that takes a number (a) as argument. If a is a whole number (has no decimal place), return true. Otherwise, return false.
function myFunction(a) {
  return Number.isInteger(a) ;
}
// also
function myFunction(a) {
  return a - Math.floor(a) === 0
}

// myFunction(4)
// Expected
// true 
// myFunction(1.123)
// Expected
// false 
// myFunction(1048)
// Expected
// true 
// myFunction(10.48)
// Expected
// false 


// Write a function that takes two numbers (a and b) as arguments. If a is smaller than b, divide a by b. Otherwise, multiply both numbers. Return the resulting value
function myFunction(a, b) {
    return a < b? a / b : a * b;
}
/*
myFunction(10, 100)
Expected
0.1
myFunction(90, 45)
Expected
4050
myFunction(8, 20)
Expected
0.4
myFunction(2, 0.5)
Expected
1
*/ 


// Write a function that takes a number (a) as argument. Round a to the 2nd digit after the comma. Return the rounded number
function myFunction(a) {
return (Math.round(a * 100)/100);
}
// also (sln)
// toFixed() returns a string that's why Number() in front
function myFunction(a) {
  return Number(a.toFixed(2));
}
// myFunction(2.12397)
// Expected
// 2.12
// myFunction(3.136)
// Expected
// 3.14
// myFunction(1.12397)
// Expected
// 1.12
// myFunction(26.1379)
// Expected
// 26.14


// Write a function that takes a number (a) as argument. Split a into its individual digits and return them in an array. Tipp: you might want to change the type of the number for the splitting
function myFunction(a) {
  const arr =[ ...a.toString()];
    return ( arr.map(Number));
}
// also
function myFunction( a ) {
  const string = a + '';
  const strings = string.split('');
  return strings.map(digit => Number(digit))
}
/*
myFunction(10)
Expected
[1,0]
myFunction(931)
Expected
[9,3,1]
myFunction(193278)
Expected
[1,9,3,2,7,8]
*/ 




// Write a function that takes a string as argument. As it is, the string has no meaning. Increment each letter to the next letter in the alphabet. Return the correct word
function myFunction(str) {
    const arr = [... str]
     arr.forEach(function(item, i){
    arr[i] = String.fromCharCode(arr[i].charCodeAt(0) + 1)
  })
    return (arr.join(""))
}
// also
function myFunction(str) {
  const arr = [...str];
  const correctedArray = arr.map(e => String.fromCharCode(e.charCodeAt()+1));
  return correctedArray.join('');
}

// myFunction('bnchmf')
// Expected
// 'coding'
// myFunction('bgddrd')
// Expected
// 'cheese'
// myFunction('sdrshmf')
// Expected
// 'testing'


// It seems like something happened to these strings. Can you figure out how to clear up the chaos? Write a function that joins these strings together such that they form the following words:. 'Javascript', 'Countryside', and 'Downtown'. You might want to apply basic JS string methods such as replace(), split(), slice() etc.
function myFunction(a, b){
  let outString = b.replace(/[`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '')
  let reversed = outString.split("").reverse().join("");
  let newWord = a + reversed;
  let finalProd = newWord.replace(/[`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '')
  console.log(finalProd[0].toUpperCase() + finalProd.substring(1));
}
// also (sugg sln)
function myFunction(a, b) {
  const func = x => x.replace('%','');
  const first = func(a);
  const second = func(b).split('').reverse().join('');
  return first.charAt(0).toUpperCase() + first.slice(1) + second;
}

// myFunction('java', 'tpi%rcs')
// Expected
// 'Javascript'
// myFunction('c%ountry', 'edis')
// Expected
// 'Countryside'
// myFunction('down', 'nw%ot')
// Expected
// 'Downtown'


// This challenge is a little bit more complex. Write a function that takes a number (a) as argument. If a is prime, return a. If not, return the next higher prime number.
// this is the closest I got to the sln
function myFunction(a){
  for (let i = 2; i < a; i++){
    if (Number.isInteger(a / i)){
    console.log(a)      
    } else for ( let j = 2; j < a; j++){
           if ((a++ % j) === 0) {
          console.log(a++);
          return a++;
             // break;
           } }
      }
 }

    function myFunction( a ) {
  function isPrime(num) {
    for (let i = 2; i <= Math.sqrt(num); i++) {
      if (num % i === 0) return false;
    }
    return num > 1;
  }
 let n = a;
 while (!isPrime(n)) n++;
return n
}
/*
myFunction(38)
Expected
41
myFunction(7)
Expected
7
myFunction(115)
Expected
127
myFunction(2000)
Expected
2003
*/ 


/********  Array    *************/ 
// Write a function that takes an array (a) and a value (n) as argument. Return the nth element of 'a'
function myFunction(a, n) {
   return a[n - 1];
}

/*myFunction([1,2,3,4,5],3)
Expected
3
myFunction([10,9,8,7,6],5)
Expected
6
myFunction([7,2,1,6,3],1)
Expected
7
*/



// Write a function that takes an array (a) as argument. Remove the first 3 elements of 'a'. Return the result
function myFunction(a) {
   return a.slice(3);
}

/*
myFunction([1,2,3,4])
Expected
[4]
myFunction([5,4,3,2,1,0])
Expected
[2,1,0]
myFunction([99,1,1])
Expected
[]
*/


// Write a function that takes an array (a) as argument. Extract the last 3 elements of 'a'. Return the resulting array
function myFunction(a){
  
  return a.slice( -3);
}
/*
myFunction([1,2,3,4])
Expected
[2,3,4]
myFunction([5,4,3,2,1,0])
Expected
[2,1,0]
myFunction([99,1,1])
Expected
[99,1,1]
*/ 


// Write a function that takes an array (a) as argument. Extract the first 3 elements of a. Return the resulting array
function myFunction(a) {
   return a.slice(0, 3);
}

/*
myFunction([1,2,3,4])
Expected
[1,2,3]
myFunction([5,4,3,2,1,0])
Expected
[5,4,3]
myFunction([99,1,1])
Expected
[99,1,1]
*/ 


// Write a function that takes an array (a) and a number (n) as arguments. It should return the last n elements of a.
function myFunction(a, n) {
  return a.slice(-n);
}

// myFunction([1, 2, 3, 4, 5], 2)
// Expected
// [ 4, 5 ]
// myFunction([1, 2, 3], 6)
// Expected
// [ 1, 2, 3 ]
// myFunction([1, 2, 3, 4, 5, 6, 7, 8], 3)
// Expected
// [ 6, 7, 8 ]


    
// <!-- Write a function that takes an array (a) and a value (b) as argument. The function should remove all elements equal to 'b' from the array. Return the filtered array. -->
    function myFunction(a, b){
      
        return a.filter( (letter) => letter !== b)
      }

// myFunction([1,2,3], 2)
// Expected
// [1, 3]
// myFunction([1,2,'2'], '2')
// Expected
// [1, 2]
// myFunction([false,'2',1], false)
// Expected
// ['2', 1]
// myFunction([1,2,'2',1], 1)
// Expected
// [2, '2']


// Write a function that takes an array (a) as argument. Return the number of elements in a.
function myFunction(a){
  
  return a.length;
}

// myFunction([1,2,2,4])
// Expected
// 4
// myFunction([9,9,9])
// Expected
// 3
// myFunction([4,3,2,1,0])
// Expected
// 5


// Write a function that takes an array of numbers as argument. Return the number of negative values in the array.
function myFunction(a){
  
  return (a.filter( (number) => number < 0)).length;
}

// myFunction([1,-2,2,-4])
// Expected
// 2
// myFunction([0,9,1])
// Expected
// 0
// myFunction([4,-3,2,1,0])
// Expected
// 1


// Write a function that takes an array of strings as argument. Sort the array elements alphabetically. Return the result.

function myFunction(arr){
  
  return arr.sort();
}

// myFunction(['b', 'c', 'd', 'a'])
// Expected
// ['a', 'b', 'c', 'd']
// myFunction(['z', 'c', 'd', 'a', 'y', 'a', 'w'])
// Expected
// ['a', 'a', 'c', 'd', 'w', 'y', 'z']



// Write a function that takes an array of numbers as argument. It should return an array with the numbers sorted in descending order.

return arr.sort((a, b) => b - a );
// also
return arr.sort().reverse();
// also
return arr.sort((a, b) => (a > b ? -1 : 1))

// myFunction([1,3,2])
// Expected
// [3,2,1]
// myFunction([4,2,3,1])
// Expected
// [4,3,2,1]



// Write a function that takes an array of numbers as argument. It should return the sum of the numbers.

function myFunction(a){
  let sum = 0;
  for (let i = 0; i < a.length; i++ ){
  sum = sum + a[i]
  }
  return sum;
}
//also
function myFunction(a){
  let sum = 0;
//   this has to run first several times to add up all elements 
  (a.forEach( a => sum += a))
//   then apply return (this ends all operations)
  return sum;
}
// also 
function myFunction(a){
return a.reduce( (a, b) => a + b, 0)
}

// myFunction([10,100,40])
// Expected
// 150
// myFunction([10,100,1000,1])
// Expected
// 1111
// myFunction([-50,0,50,200])
// Expected
// 200



// Write a function that takes an array of numbers as argument. It should return the average of the numbers.

function myFunction(a){
 let sum = 0;
  (a.forEach( a => sum += a))
  return sum / a.length;
}
// also
function myFunction(a){
return (a.reduce( (a, b) => a + b, 0) / a.length); 
}

// myFunction([10,100,40])
// Expected
// 50
// myFunction([10,100,1000])
// Expected
// 370
// myFunction([-50,0,50,200])
// Expected
// 50


// Write a function that takes an array of strings as argument. Return the longest string.

function myFunction(arr){
return arr.reduce( (a, b) => a.length >= b.length ? a : b); 
}

// myFunction(['help', 'me'])
// Expected
// 'help'
// myFunction(['I', 'need', 'candy'])
// Expected
// 'candy'



// Write a function that takes an array as argument. It should return true if all elements in the array are equal. It should return false otherwise.

function myFunction(arr){
  return arr.every(a => a === arr[0] ? true : false);
  }
//   also 
function myFunction(arr){
    return new Set(arr).size === 1;
  }
// myFunction([true, true, true, true])
// Expected
// true 
// myFunction(['test', 'test', 'test'])
// Expected
// true 
// myFunction([1,1,1,2])
// Expected
// false 
// myFunction(['10',10,10,10])
// Expected
// false 


// Write a function that takes arguments an arbitrary number of arrays. It should return an array containing the values of all arrays.
function myFunction(...arrays){

return ([].concat(...arrays));
}
// also 
function myFunction(...arrays){

return array.flat();
// where default value is 1
}


// myFunction([1, 2, 3], [4, 5, 6])
// Expected
// [1, 2, 3, 4, 5, 6]
// myFunction(['a', 'b', 'c'], [4, 5, 6])
// Expected
// ['a', 'b', 'c', 4, 5, 6]
// myFunction([true, true], [1, 2], ['a', 'b'])
// Expected
// [true, true, 1, 2, 'a', 'b']




// Write a function that takes an array of objects as argument. Sort the array by property b in ascending order. Return the sorted array

function myFunction(arr){

return arr.sort((one, two) => one.b - two.b );
}
//also
function myFunction(arr) {
   const sort = (x, y) => x.b - y.b;
   return arr.sort(sort);
}

// myFunction([{a:1,b:2},{a:5,b:4}])
// Expected
// [{a:1,b:2},{a:5,b:4}]
// myFunction([{a:2,b:10},{a:5,b:4}])
// Expected
// [{a:5,b:4},{a:2,b:10}]
// myFunction([{a:1,b:7},{a:2,b:1}])
// Expected
// [{a:2,b:1},{a:1,b:7}]




// Write a function that takes two arrays as arguments. Merge both arrays and remove duplicate values. Sort the merge result in ascending order. Return the resulting array

function myFunction(a, b){
  let newArray = (a.concat(b))
  let sorted = newArray.sort((a, b) => a - b)
  return [...new Set(sorted)];
}
// also (suggested sln)
function myFunction(a, b) {
  return [...new Set([...a, ...b])].sort((x, y) => x - y);
}

// myFunction([1, 2, 3], [3, 4, 5])
// Expected
// [ 1, 2, 3, 4, 5 ]
// myFunction([-10, 22, 333, 42], [-11, 5, 22, 41, 42])
// Expected
// [ -11, -10, 5, 22, 41,  42, 333]


// Write a function that takes an array (a) and a number (b) as arguments. Sum up all array elements with a value greater than b. Return the sum
function myFunction(a, b){
  let sum = 0;
  for (let i = 0; i < a.length; i++ ){
    if (b < a[i]) sum += a[i] 
  }
  return (sum);
}
// also (suggested sln)
function myFunction(a, b) {
  return a.reduce((sum, cur) => {
    if (cur > b) return sum + cur;
    return sum;
  }, 0);
}

/* 
myFunction([1, 2, 3, 4, 5, 6, 7], 2)
Expected
25
myFunction([-10, -11, -3, 1, -4], -3)
Expected
1
myFunction([78, 99, 100, 101, 401], 99)
Expected
602
*/


// Write a function that takes two numbers (min and max) as arguments. Return an array of numbers in the range min to max
function myFunction(min, max){
  return (min <= max ? [min, ...myFunction(min + 1, max)] : [] );
}
// also
function myFunction(min, max){
    let arr = [];
  for (let i = min; i <= max; i++) {
    arr.push(i);
  }
return arr;
}
/*
myFunction(2, 10)
Expected
[2, 3, 4, 5, 6, 7, 8, 9, 10]
myFunction(1, 3)
Expected
[1, 2, 3]
myFunction(-5, 5)
Expected
[-5, -4, -3, -2, -1, 0,  1,  2,  3,  4, 5]
myFunction(2, 7)
Expected
[2, 3, 4, 5, 6, 7]
*/ 


// Write a function that takes an array of strings as argument. Group those strings by their first letter. Return an object that contains properties with keys representing first letters. The values should be arrays of strings containing only the corresponding strings. For example, the array ['Alf', 'Alice', 'Ben'] should be transformed to. { a: ['Alf', 'Alice'], b: ['Ben']}
// return a string for key
function myFunction(arr){
return arr.reduce((store, word) => {
    // store first letter 
    const letter = word.charAt(0)
    const keyStore = (
      store[letter] ||     // Does it exist in the object?
      (store[letter] = []) // If not, create it as an empty array
    ); 
    keyStore.push(word)
    return store
  }, {})
}
// also (provided solution)
function myFunction(arr) {
 return arr.reduce((acc, cur) => {
   const firstLetter = cur.toLowerCase().charAt(0);
   return { ...acc, [firstLetter]: [...(acc[firstLetter] || []), cur] };
 }, {});
}

/*
myFunction(['Alf', 'Alice', 'Ben'])
Expected
{ a: ['Alf', 'Alice'], b: ['Ben']}
myFunction(['Ant', 'Bear', 'Bird'])
Expected
{ a: ['Ant'], b: ['Bear', 'Bird']}
myFunction(['Berlin', 'Paris', 'Prague'])
Expected
{ b: ['Berlin'], p: ['Paris', 'Prague']}
*/ 


// Write a function that takes an array with arbitrary elements and a number as arguments. Return a new array, the first element should be either the given number itself or zero if the number is smaller than 6. The other elements should be the elements of the original array. Try not to mutate the original array
function myFunction(arr, num) {
let newArray = (arr.concat(num));
  if (  typeof arr[0] === "number" || num > arr[0]  ) {
     newArray.unshift(num);
  } else if ( arr[0] !== "number") {
    newArray.pop(arr.length-1);
    newArray.unshift(0);
  } 
  return [...new Set(newArray)];
}
// also (suggested sln)
function myFunction(arr, num) {
 return [...(num > 5 ? [num] : [0]), ...arr];
}
/*
myFunction([1,2,3], 6)
Expected
[6,1,2,3]
myFunction(['a','b'], 2)
Expected
[0,'a','b']
myFunction([null,false], 11)
Expected
[11,null,false]
*/ 

// Write a function that takes an array (a) and a value (n) as arguments. Save every nth element in a new array. Return the new array
function myFunction(a, n) {
   let newArray = [];
    for (let i = 0; i < a.length-1; i = i + n){
      newArray = [...newArray, a[i + n-1]]; 
  }
     return newArray;
}
// also (suggested sln)
function myFunction(a, n) {
   let rest = [...a];
   let result = [];
   for (let i = 0; i < a.length; i++) {
      if (rest.length < n) break;
      result.push(rest[n - 1]);
      rest = rest.slice(n);
   }
   return result;
}
/*
myFunction([1,2,3,4,5,6,7,8,9,10],3)
Expected
[3,6,9]
myFunction([10,9,8,7,6,5,4,3,2,1],5)
Expected
[6,1]
myFunction([7,2,1,6,3,4,5,8,9,10],2)
Expected
[2,6,4,8,10]
*/ 

/* ******* Objects ******* */

// Write a function that takes an object with two properties as argument. It should return the value of the property with key country.

function myFunction(obj){
return obj.country; // or =>  return obj["country"];
}

// myFunction({ continent: 'Asia', country: 'Japan' })

// myFunction({ country: 'Sweden', continent: 'Europe' })



// Write a function that takes an object with two properties as argument. It should return the value of the property with key 'prop-2'. Tipp: you might want to use the square brackets property accessor

function myFunction(obj) {
  return obj['prop-2']
}

// myFunction({  one: 1,  'prop-2': 2})
// Expected
// 2
// myFunction({  'prop-2': 'two',  prop: 'test'})
// Expected
// 'two'



// Write a function that takes an object with two properties and a string as arguments. It should return the value of the property with key equal to the value of the string

function myFunction(obj, key){
return (obj[key]);
}

// myFunction({  continent: 'Asia',  country: 'Japan'}, 'continent')
// Expected
// 'Asia'
// myFunction({  country: 'Sweden',  continent: 'Europe'}, 'country')
// Expected
// 'Sweden'


// Write a function that takes an object (a) and a string (b) as argument. Return true if the object has a property with key 'b'. Return false otherwise. Tipp: test case 3 is a bit tricky because the value of property 'z' is undefined. But the property itself exists.

function myFunction(a, b) {
   return b in a;
}

// myFunction({a:1,b:2,c:3},'b')
// Expected
// true
// myFunction({x:'a',y:'b',z:'c'},'a')
// Expected
// false
// myFunction({x:'a',y:'b',z:undefined},'z')
// Expected
// true


// Write a function that takes an object (a) and a string (b) as argument. Return true if the object has a property with key 'b', but only if it has a truthy value. In other words, it should not be null or undefined or false. Return false otherwise.

function myFunction( a, b){
return a[b] ? true : false ;
}
// also 
function myFunction( a, b){
    return Boolean(a[b]);
}
// also
function myFunction(a, b){
    return !!a[b];
}

/* myFunction({a:1,b:2,c:3},'b')
Expected
true
myFunction({x:'a',y:null,z:'c'},'y')
Expected
false
myFunction({x:'a',b:'b',z:undefined},'z')
Expected
false
*/


// Write a function that takes a string as argument. Create an object that has a property with key 'key' and a value equal to the string. Return the object.

function myFunction(a){
    return {key: a};
}

// myFunction('a')
// Expected
// {key:'a'}
// myFunction('z')
// Expected
// {key:'z'}
// myFunction('b')
// Expected
// {key:'b'}


// Write a function that takes two strings (a and b) as arguments. Create an object that has a property with key 'a' and a value of 'b'. Return the object.

function myFunction(a, b) {
   return { [a]: b };
}

// myFunction('a','b')
// Expected
// {a:'b'}
// myFunction('z','x')
// Expected
// {z:'x'}
// myFunction('b','w')
// Expected
// {b:'w'}

// Write a function that takes two arrays (a and b) as arguments. Create an object that has properties with keys 'a' and corresponding values 'b'. Return the object.
function myFunction(a, b){
      return a.reduce((acc, cur, i) => ({ ...acc, [cur]: b[i] }), {})
   }
// myFunction(['a','b','c'],[1,2,3])
// Expected
// {a:1,b:2,c:3}
// myFunction(['w','x','y','z'],[10,9,5,2])
// Expected
// {w:10,x:9,y:5,z:2}
// myFunction([1,'b'],['a',2])
// Expected
// {1:'a',b:2}


// Write a function that takes an object (a) as argument. Return an array with all object keys.
function myFunction(a){
return Object.keys(a).filter(key => []);
  
}
// also 
function myFunction(a) {
   return Object.keys(a);
}
// myFunction({a:1,b:2,c:3})
// Expected
// ['a','b','c']
// myFunction({j:9,i:2,x:3,z:4})
// Expected
// ['j','i','x','z']
// myFunction({w:15,x:22,y:13})
// Expected
// ['w','x','y']


// Write a function that takes an object as argument. In some cases the object contains other objects with some deeply nested properties. Return the property 'b' of object 'a' inside the original object if it exists. If not, return undefined

function myFunction(obj) {
    return obj.a ? obj.a.b : undefined;
}
// also 
function myFunction(obj) {
   return obj?.a?.b;
}
// myFunction({a:1})
// Expected
// undefined
// myFunction({a:{b:{c:3}}})
// Expected
// {c:3}
// myFunction({b:{a:1}})
// Expected
// undefined
// myFunction({a:{b:2}})
// Expected
// 2


// Write a function that takes an object (a) as argument. Return the sum of all object values.
function myFunction(a) {
   return Object.values(a).reduce((sum, cur) => sum + cur, 0);
}

// myFunction({a:1,b:2,c:3})
// Expected
// 6
// myFunction({j:9,i:2,x:3,z:4})
// Expected
// 18
// myFunction({w:15,x:22,y:13})
// Expected
// 50



// Write a function that takes an object as argument. It should return an object with all original object properties. except for the property with key 'b'
// (my notes) the delete method is not recommended b/c it can cause side effects in the code
function myFunction(obj){
  delete obj.b;
  return obj ;
}

// also 
function myFunction(obj) {
  const { b, ...rest } = obj;
  return rest;
}
// myFunction({ a: 1, b: 7, c: 3 })
// Expected
// { a: 1, c: 3 }
// myFunction({ b: 0, a: 7, d: 8 })
// Expected
// { a: 7, d: 8 }
// myFunction({ e: 6, f: 4, b: 5, a: 3 })
// Expected
// { e: 6, f: 4, a: 3 }



// Write a function that takes two objects as arguments. Unfortunately, the property 'b' in the second object has the wrong key. It should be named 'd' instead. Merge both objects and correct the wrong property name. Return the resulting object. It should have the properties 'a', 'b', 'c', 'd', and 'e'
function myFunction(x, y){
   y.d = y.b; 
  delete y.b;
 return {...x, ...y};
}
// also
function myFunction(x, y) {
  const { b, ...rest } = y;
  return { ...x, ...rest, d: b };
}
// myFunction({ a: 1, b: 2 }, { c: 3, b: 4, e: 5 })
// Expected
// { a: 1, b: 2, c: 3, e: 5, d: 4}
// myFunction({ a: 5, b: 4 }, { c: 3, b: 1, e: 2 })
// Expected
// { a: 5, b: 4, c: 3, e: 2, d: 1}


// Write a function that takes an object (a) and a number (b) as arguments. Multiply all values of 'a' by 'b'. Return the resulting object.
function myFunction(a, b) {
  const newObj = {};
  const keys = Object.keys(a)
  for (let i = 0; i < keys.length; i++){
    newObj[keys[i]] = a[keys[i]] * b;
  }
   return newObj;
}
// also (suggested sln)
function myFunction(a, b) {
   return Object.entries(a).reduce((acc, [key, val]) => {
   	return { ...acc, [key]: val * b };
   }, {});
}
/*
myFunction({a:1,b:2,c:3},3)
Expected
{a:3,b:6,c:9}
myFunction({j:9,i:2,x:3,z:4},10)
Expected
{j:90,i:20,x:30,z:40}
myFunction({w:15,x:22,y:13},6)
Expected
{w:90,x:132,y:78}
*/ 

// Write a function that takes an object as argument. Somehow, the properties and keys of the object got mixed up. Swap the Javascript object's key with its values and return the resulting object
function myFunction(obj) {
  const newValues = Object.keys(obj)
  const newKeys = Object.values(obj)
 const combineArrays = (first, second) => {
   return first.reduce((acc, val, ind) => {
      acc[val] = second[ind];
      return acc;
   }, {});
};
 return combineArrays(newKeys, newValues);
}
// or 
function myFunction (obj){
  const newValues = Object.keys(obj)
  const newKeys = Object.values(obj)  
    const newObj = {};
    for (var i=0; i<newKeys.length; i++) {
    newObj[newKeys[i]] = newValues[i];
}
return newObj;
}

// also (suggested sln )
function myFunction(obj) {
   return Object.entries(obj).reduce((acc, [key, val]) => {
      return { ...acc, [val]: key };
   }, {});
}
// myFunction({z:'a',y:'b',x:'c',w:'d'})
// Expected
// {a:'z',b:'y',c:'x',d:'w'}
// myFunction({2:'a',4:'b',6:'c',8:'d'})
// Expected
// {a:'2',b:'4',c:'6',d:'8'}
// myFunction({a:1,z:24})
// Expected
// {1:'a',24:'z'}



// Write a function that takes an object as argument containing properties with personal information. Extract firstName, lastName, size, and weight if available. If size or weight is given transform the value to a string. Attach the unit cm to the size. Attach the unit kg to the weight. Return a new object with all available properties that we are interested in
function myFunction(obj) {
  const {age, email, ...rest} = obj;
  Object.keys(rest).forEach(function(key) {
  if (typeof(rest.size) == 'number') {
    return rest.size = rest.size + "cm";
  }
    if (typeof(rest.weight) == 'number') {
    return rest.weight = rest.weight + "kg";
  }
})
  return (rest);
}
// marta's sln
function myFunction(obj) {
const rest = {};
  rest.fn = obj.fn;
  rest.ln = obj.ln;
  if (obj.size) {
    rest.size = obj.size + 'cm'
  };
  if (obj.weight) {
    rest.weight = obj.weight + 'kg'
  }
  return (rest);
}
// also (sln)
function myFunction(obj) {
  return {
    fn: obj.fn,
    ln: obj.ln,
    ...(obj.size && { size: `${obj.size}cm` }),
    ...(obj.weight && { weight: `${obj.weight}kg` }),
  };
}
/*
myFunction({fn: 'Lisa', ln: 'Müller', age: 17, size: 175, weight: 67})
Expected
{fn: 'Lisa', ln: 'Müller', size: '175cm', weight: '67kg'}
myFunction({fn: 'Martin', ln: 'Harper', age: 26, email: 'martin.harper@test.de', weight: 102})
Expected
{fn: 'Martin', ln: 'Harper', weight: '102kg'}
myFunction({fn: 'Andrew', ln: 'Harper', age: 81, size: 175, weight: 71})
Expected
{fn: 'Andrew', ln: 'Harper', size: '175cm', weight: '71kg'}
myFunction({fn: 'Matthew', ln: 'Müller', age: 19, email: 'matthew@mueller.de'})
Expected
{fn: 'Matthew', ln: 'Müller'}
*/ 


// Write a function that takes an object as argument. Some of the property values contain empty strings. Replace empty strings and strings that contain only whitespace with null values. Return the resulting object
function myFunction(obj) {
Object.keys(obj).forEach(value => {
  if (obj[value] === ''|| obj[value] === ' '){
  obj[value] = null
  };
  });
 return (obj);
}

// (suggested sln)
function myFunction(obj) {
  const newObj = { ...obj };
  for (key in newObj) {
    if (newObj[key].trim() === '') newObj[key] = null;
  }
  return newObj;
}
/*
myFunction({ a: 'a', b: 'b', c: '' })
Expected
{ a: 'a', b: 'b', c: null }
myFunction({ a: '', b: 'b', c: ' ', d: 'd' })
Expected
{ a: null, b: 'b', c: null, d: 'd' }
myFunction({ a: 'a', b: 'b ', c: ' ', d: '' })
Expected
{ a: 'a', b: 'b ', c: null, d: null }
*/ 


// Write a function that takes an array of objects and a string as arguments. Add a property with key 'continent' and value equal to the string to each of the objects. Return the new array of objects. Tipp: try not to mutate the original array
// coun't find a sln 

// suggested sln
function myFunction(arr, str) {
  return arr.map((obj) => ({ ...obj, continent: str }));
}
/*
myFunction([{ city: 'Tokyo', country: 'Japan' }, { city: 'Bangkok', country: 'Thailand' }], 'Asia')
Expected
[{ city: 'Tokyo', country: 'Japan', continent: 'Asia' }, { city: 'Bangkok', country: 'Thailand', continent: 'Asia' }]
myFunction([{ city: 'Stockholm', country: 'Sweden' }, { city: 'Paris', country: 'France' }], 'Europe')
Expected
[{ city: 'Stockholm', country: 'Sweden', continent: 'Europe' }, { city: 'Paris', country: 'France', continent: 'Europe' }]
*/ 

// Write a function that takes an array of numbers as argument. Convert the array to an object. It should have a key for each unique value of the array. The corresponding object value should be the number of times the key occurs within the array.
function myFunction(a) {
let counter = {};
for (element of a) {
    if (counter[element]) {
        counter[element] += 1;
    } else {
        counter[element] = 1;
    }
};
    return (counter);
}
// or 
function myFunction(a) {
    let countObject = myArray.reduce((count, element) => 
    {return (count[element] ? ++count[element] : (count[element] = 1), count);
    },
{});
}
// also 
function myFunction(a) {
   return a.reduce((acc, cur) => {
   	return { ...acc, [cur]: (acc[cur] || 0) + 1 };
   }, {});
}
/*
myFunction([1,2,2,3])
Expected
{1:1,2:2,3:1}
myFunction([9,9,9,99])
Expected
{9:3,99:1}
myFunction([4,3,2,1])
Expected
{1:1,2:1,3:1,4:1}
*/


/* ************  Dates ************ */
// Sounds easy, but you need to know the trick. Write a function that takes two date instances as arguments. It should return true if the dates are equal. It should return false otherwise.
function myFunction(a, b){
  return( a.getTime() === b.getTime() ? true : false);
}
// or 
function myFunction(a, b){
    if (a.getTime() === b.getTime()) {
        console.log(true)
    }else {
        console.log(false)
    }
}
// also
function myFunction(a, b) {
     return a.getTime() === b.getTime();
}
/*
myFunction(new Date('2000/01/01 08:00:00'), new Date('2000/01/01 08:45:00'))
Expected
false
myFunction(new Date('2000/01/01 08:00:00'), new Date('2000/01/01 08:00:00'))
Expected
true
myFunction(new Date('2001/01/01 08:00:00'), new Date('2000/01/01 08:00:00'))
Expected
false
*/ 

// Write a function that takes two date instances as argument. It should return the number of days that lies between those dates.
function myFunction(a, b){
  const diff = Math.abs(a.getTime() - b.getTime());
  return (diff / (1000 * 3600 * 24));
}
// also 
function myFunction(a, b) {
   const dif = Math.abs(a - b);
   return dif / 1000 / 60 / 60 / 24
}
// myFunction(new Date('2020-06-11'), new Date('2020-06-01'))
// Expected
// 10
// myFunction(new Date('2000-01-01'), new Date('2020-06-01'))
// Expected
// 7457


// Write a function that takes two date instances as argument. It should return true if they fall on the exact same day. It should return false otherwise.
function myFunction(a, b){
  const diff = Math.abs(b.getTime() - a.getTime());
  return(diff > 0 ? false : true);
}
//also 
function myFunction(a, b) {
  return a.getFullYear() === b.getFullYear() &&
         a.getMonth() === b.getMonth() &&
         a.getDate()=== b.getDate()
}
/*
myFunction(new Date('2000/01/01'), new Date('2000/01/01'))
Expected
true 
myFunction(new Date('2000/01/01'), new Date('2000/01/02'))
Expected
false 
myFunction(new Date('2001/01/01'), new Date('2000/01/01'))
Expected
false 
myFunction(new Date('2000/11/01'), new Date('2000/01/01'))
Expected
false 
*/ 

// Write a function that takes two date instances as argument. It should return true if the difference between the dates is less than or equal to 1 hour. It should return false otherwise.
function myFunction(a, b){
  const diff = Math.abs(a - b);
  const hour = (diff / (1000 * 60 * 24 ));
  return (hour > 2.5 ? false : true);
}
// also
function myFunction(a, b) {
   return Math.abs(a - b) / 1000 / 60 <= 60
}
/*
myFunction(new Date('2000/01/01 08:00:00'), new Date('2000/01/01 08:45:00'))
Expected
true 
myFunction(new Date('2000/01/01 09:00:00'), new Date('2000/01/01 08:45:00'))
Expected
true 
myFunction(new Date('2000/01/01 08:00:00'), new Date('2000/01/01 09:45:00'))
Expected
false 
myFunction(new Date('2000/01/01 08:00:00'), new Date('2000/01/01 09:00:00'))
Expected
true 
*/ 


// Write a function that takes two date instances (a and b) as arguments. It should return true if a is earlier than b. It should return false otherwise.
function myFunction(a, b){
   return ((a - b) < 0 ? true : false);
}
// also 
function myFunction(a, b) {
   return a < b
}
/*
myFunction(new Date('2000/01/01 08:00:00'), new Date('2000/01/01 08:45:00'))
Expected
true 
myFunction(new Date('2000/01/01 08:45:00'), new Date('2000/01/01 08:00:00'))
Expected
false 
myFunction(new Date('2000/01/01 08:00:00'), new Date('2000/01/01 08:00:00'))
Expected
false 
*/ 


// Write a function that takes as argument a date instance (a) and a number (b). It should add b days to a and return the number of milliseconds since January 1, 1970, 00:00:00 UTC.
function myFunction(a, b){
  const daysInMilsec = b * 1000 * 3600 * 24;
  return ( Date.parse(a) + daysInMilsec);
}
// also
function myFunction(a, b) {
  const currentDays = a.getDate();
  return a.setDate(currentDays + b)
}
/*
myFunction(new Date(Date.UTC(2000,01,01)), 31)
Expected
952041600000
myFunction(new Date(Date.UTC(2000,01,01)), 10)
Expected
950227200000
myFunction(new Date(Date.UTC(2000,02,28,)), 2)
Expected
954374400000
*/ 

// This is a more difficult challenge. Write a function that takes two date instances as arguments. It should return an object with the properties 'hrs', 'min', and 'sec'. The corresponding values should display the absolute difference between the two dates in hours, minutes, and seconds.
function myFunction(a, b){
  const duration = Math.abs(a - b); 
const sec = Math.floor((duration / 1000) % 60);
const min = Math.floor((duration / (1000 * 60)) % 60);
const hrs = Math.floor((duration / (1000 * 60 * 60)) % 24);
 return({hrs, min, sec});
}
// also 
function myFunction(a, b) {
  const dif = Math.abs(a - b);
  const hrs = Math.floor(dif / 1000 / 60 / 60);
  const min = Math.floor(dif / 1000 / 60) % (hrs * 60 || 60);
  const sec = Math.floor(dif / 1000) % (min * 60 + hrs * 60 * 60 || 60);
  return { hrs, min, sec }
}
/*
myFunction(new Date('2000/01/01 08:00:00'), new Date('2000/01/01 08:45:10'))
Expected
{ hrs: 0, min: 45, sec: 10 }
myFunction(new Date('2000/01/01 09:50:23'), new Date('2000/01/01 08:00:00'))
Expected
{ hrs: 1, min: 50, sec: 23 }
myFunction(new Date('2000/01/01 11:04:12'), new Date('2000/01/01 08:00:00'))
Expected
{ hrs: 3, min: 4, sec: 12 }
*/ 


// Write a function that takes a Date instance as argument. It should return the next nearest quarter hour in minutes. For example, if the given date has the time 10:01 the function should return 15
function myFunction(date){
  const minutes = date.getMinutes();
  return (Math.ceil(minutes/15) * 15) % 60;
}
// also (suggested sln)
function myFunction(date) {
const quarter = 15 * 60 * 1000;
const closestQuarter = new Date(Math.round(date / quarter) * quarter);
const nextQuarter = closestQuarter.getTime() < date.getTime() ? new Date(closestQuarter.getTime() + quarter) : closestQuarter;
return nextQuarter.getMinutes();
}
// myFunction(new Date(2021, 8, 10, 15, 14, 00))
// Expected
// 15
// myFunction(new Date(2021, 8, 10, 15, 31, 00))
// Expected
// 45
// myFunction(new Date(2021, 8, 10, 15, 22, 00))
// Expected
// 30


/******** Sets ***********/

// Write a function that takes a Set and a value as arguments. Check if the value is present in the Set
function myFunction(set, val){
  
  return (set.has(val));
}
/*
myFunction(new Set([1, 2, 3]), 2)
Expected
true
myFunction(new Set([123]), 2)
Expected
false
myFunction(new Set(['1', '2', '3']), '2')
Expected
true
myFunction(new Set('123'), '2')
Expected
true
*/ 

// Write a function that takes a Set as argument. Convert the Set to an Array. Return the Array
function myFunction(set){
  return (Array.from(set));
}
// also 
function myFunction(set) {
  return [...set];
}

//  myFunction(new Set([1, 2, 3]))
// Expected
// [1, 2, 3]
// myFunction(new Set([123]))
// Expected
// [123]
// myFunction(new Set(['1', '2', '3']))
// Expected
// ['1', '2', '3']
// myFunction(new Set('123'))
// Expected
// ['1', '2', '3']

</script>