<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Code Camp</title>
</head>
<body>
    <script>
    /*
    
    
    In the game of Golf, each hole has a par, meaning, the average number of strokes a golfer is expected to make in order to sink the ball in the hole to complete the play. Depending on how far above or below par your strokes are, there is a different nickname.
    
    Your function will be passed par and strokes arguments. Return the correct string according to this table which lists the strokes in order of priority; top (highest) to bottom (lowest):
    Strokes	Return
    1	"Hole-in-one!"
    <= par - 2	"Eagle"
    par - 1	"Birdie"
    par	"Par"
    par + 1	"Bogey"
    par + 2	"Double Bogey"
    >= par + 3	"Go Home!"
    
    par and strokes will always be numeric and positive. We have added an array of all the names for your convenience.
    
    */
    const names = ["Hole-in-one!", "Eagle", "Birdie", "Par", "Bogey", "Double Bogey", "Go Home!"];

function golfScore(par, strokes) {
  // Only change code below this line
if (strokes == 1){
  return names[0]
}else if (strokes <= par - 2){
  return names[1]
}else if (strokes == par - 1){
  return names[2]
}else if (strokes == par){
  return names[3]
}else if (strokes == par + 1){
  return names[4]
}else if (strokes == par + 2){
  return names[5]
}else if (strokes >= par + 3){
  return names[6]
}
  return "Change Me";
  // Only change code above this line
}

golfScore(5, 4);





/*
In a switch statement you may not be able to specify all possible values as case statements. Instead, you can add the default statement which will be executed if no matching case statements are found. Think of it like the final else statement in an if/else chain.

A default statement should be the last case.

switch (num) {
  case value1:
    statement1;
    break;
  case value2:
    statement2;
    break;
...
  default:
    defaultStatement;
    break;
}

Write a switch statement to set answer for the following conditions:
a - apple
b - bird
c - cat
default - stuff
*/ 
function switchOfStuff(val) {
  let answer = "";
  // Only change code below this line
switch (val){
  case "a": 
    answer = "apple";
    break;
  case "b": 
    answer = "bird";
    break;
  case "c": 
    answer = "cat";
    break;
  default: 
    answer = "stuff";
    break;
}
  // Only change code above this line
  return answer;
}

switchOfStuff(1);


/*
Multiple Identical Options in Switch Statements

If the break statement is omitted from a switch statement's case, the following case statement(s) are executed until a break is encountered. If you have multiple inputs with the same output, you can represent them in a switch statement like this:

let result = "";
switch (val) {
  case 1:
  case 2:
  case 3:
    result = "1, 2, or 3";
    break;
  case 4:
    result = "4 alone";
}

Cases for 1, 2, and 3 will all produce the same result.

Write a switch statement to set answer for the following ranges:
1-3 - Low
4-6 - Mid
7-9 - High

Note: You will need to have a case statement for each number in the range.
*/ 

function sequentialSizes(val) {
  let answer = "";
  // Only change code below this line
switch (val){
  case 1:
  case 2:
  case 3:
    answer = "Low"
    break;
  case 4:
  case 5: 
  case 6:
    answer = "Mid"
    break;
  case 7:
  case 8:
  case 9:
    answer = "High" 
}
  // Only change code above this line
  return answer;
}

sequentialSizes(1);

/*
 Counting Cards

In the casino game Blackjack, a player can determine whether they have an advantage on the next hand over the house by keeping track of the relative number of high and low cards remaining in the deck. This is called Card Counting.

Having more high cards remaining in the deck favors the player. Each card is assigned a value according to the table below. When the count is positive, the player should bet high. When the count is zero or negative, the player should bet low.
Count Change	Cards
+1	2, 3, 4, 5, 6
0	7, 8, 9
-1	10, 'J', 'Q', 'K', 'A'

You will write a card counting function. It will receive a card parameter, which can be a number or a string, and increment or decrement the global count variable according to the card's value (see table). The function will then return a string with the current count and the string Bet if the count is positive, or Hold if the count is zero or negative. The current count and the player's decision (Bet or Hold) should be separated by a single space.

Example Outputs: -3 Hold or 5 Bet

Hint
Do NOT reset count to 0 when value is 7, 8, or 9.
Do NOT return an array.
Do NOT include quotes (single or double) in the output.
Tests

Passed: Your function should return a value for count and the text (Bet or Hold) with one space character between them.
Passed: Cards Sequence 2, 3, 4, 5, 6 should return the string 5 Bet
Passed: Cards Sequence 7, 8, 9 should return the string 0 Hold
Passed: Cards Sequence 10, J, Q, K, A should return the string -5 Hold
Passed: Cards Sequence 3, 7, Q, 8, A should return the string -1 Hold
Passed: Cards Sequence 2, J, 9, 2, 7 should return the string 1 Bet
Passed: Cards Sequence 2, 2, 10 should return the string 1 Bet
Passed: Cards Sequence 3, 2, A, 10, K should return the string -1 Hold
 */
 
 let count = 0;

function cc(card) {
  // Only change code below this line
switch (card){
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
    count++;
    break;
    // these lines below are not needed 
  // case 7: 
  // case 8: 
  // case 9: 
  //   break;
  case 10: 
  case "J": 
  case "Q":
  case "K": 
  case "A": 
    count--;
    break;
}
  if (count > 0 ){
    return (`${count} Bet`);
  } else if(count < 0){
    return (`${count} Hold`);
  } else {
    console.log(count)
    return (`${count} Hold`); 
  };
  // Only change code above this line
}

// sugested sln 
let counts = 0;
function cc(card) {
  if (card <= 6) 
    counts++;
  else if (card >="10")
//   here type coersion is turning a "string" to a number and also b/c numbers come before letters in a dictionary letters are larger thus "K" > "10" returns true also "B" > "A" so "Z" is larger than the rest of them
    counts--;
  return counts + (counts > 0 ? ' Bet' : ' Hold');
}
// cc(2); cc(3); cc(7); cc('K');  cc('A');




/*
You are given an object literal representing a part of your musical album collection. Each album has a unique id number as its key and several other properties. Not all albums have complete information.

You start with an updateRecords function that takes an object literal, records, containing the musical album collection, an id, a prop (like artist or tracks), and a value. Complete the function using the rules below to modify the object passed to the function.

   Your function must always return the entire record collection object.
   If prop isn't tracks and value isn't an empty string, update or set that album's prop to value.
   If prop is tracks but the album doesn't have a tracks property, create an empty array and add value to it.
   If prop is tracks and value isn't an empty string, add value to the end of the album's existing tracks array.
   If value is an empty string, delete the given prop property from the album.

Note: A copy of the recordCollection object is used for the tests.
Tests

Passed: After updateRecords(recordCollection, 5439, "artist", "ABBA"), artist should be the string ABBA
Passed: After updateRecords(recordCollection, 5439, "tracks", "Take a Chance on Me"), tracks should have the string Take a Chance on Me as the last and only element.
Passed: After updateRecords(recordCollection, 2548, "artist", ""), artist should not be set
Passed: After updateRecords(recordCollection, 1245, "tracks", "Addicted to Love"), tracks should have the string Addicted to Love as the last element.
Passed: After updateRecords(recordCollection, 2468, "tracks", "Free"), tracks should have the string 1999 as the first element.
Passed: After updateRecords(recordCollection, 2548, "tracks", ""), tracks should not be set
Passed: After updateRecords(recordCollection, 1245, "albumTitle", "Riptide"), albumTitle should be the string Riptide
*/
// Setup
const recordCollection = {
  2548: { //id
    albumTitle: 'Slippery When Wet', // prop : value
    artist: 'Bon Jovi',
    tracks: ['Let It Rock', 'You Give Love a Bad Name']
  },
  2468: {
    albumTitle: '1999',
    artist: 'Prince',
    tracks: ['1999', 'Little Red Corvette']
  },
  1245: {
    artist: 'Robert Palmer',
    tracks: []
  },
  5439: {
    albumTitle: 'ABBA Gold'
  }
};

// Only change code below this line
function updateRecords(records, id, prop, value) {
  if (prop !== 'tracks' && value !== "") {
    records[id][prop] = value;
  } else if (prop === "tracks" && records[id].hasOwnProperty("tracks") === false){
    records[id][prop] = [value];
  } else if (prop === "tracks" && value !== "") {
    records[id][prop].push(value);
  } else if (value === "") {
    delete records[id][prop];
  }
  return records;
}


updateRecords(recordCollection, 5439, 'artist', 'ABBA');


/*
Replace Loops using Recursion

Recursion is the concept that a function can be expressed in terms of itself. To help understand this, start by thinking about the following task: multiply the first n elements of an array to create the product of those elements. Using a for loop, you could do this:

  function multiply(arr, n) {
    let product = 1;
    for (let i = 0; i < n; i++) {
      product *= arr[i];
    }
    return product;
  }

However, notice that multiply(arr, n) == multiply(arr, n - 1) * arr[n - 1]. That means you can rewrite multiply in terms of itself and never need to use a loop.

  function multiply(arr, n) {
    if (n <= 0) {
      return 1;
    } else {
      return multiply(arr, n - 1) * arr[n - 1];
    }
  }

The recursive version of multiply breaks down like this. In the base case, where n <= 0, it returns 1. For larger values of n, it calls itself, but with n - 1. That function call is evaluated in the same way, calling multiply again until n <= 0. At this point, all the functions can return and the original multiply returns the answer.

Note: Recursive functions must have a base case when they return without calling the function again (in this example, when n <= 0), otherwise they can never finish executing.

Write a recursive function, sum(arr, n), that returns the sum of the first n elements of an array arr.
Tests

Passed: sum([1], 0) should equal 0.
Passed: sum([2, 3, 4], 1) should equal 2.
Passed: sum([2, 3, 4, 5], 3) should equal 9.
Passed: Your code should not rely on any kind of loops (for or while or higher order functions such as forEach, map, filter, or reduce.).
Passed: You should use recursion to solve this problem.
*/ 
function sum(arr, n) {
  // Only change code below this line
  let total = 0;
if (n <= 0){
  return total;
} else {
  return sum(arr, n - 1) + arr[n-1];
}
  // Only change code above this line
}




/*
Profile Lookup

We have an array of objects representing different people in our contacts lists.

A lookUpProfile function that takes name and a property (prop) as arguments has been pre-written for you.

The function should check if name is an actual contact's firstName and the given property (prop) is a property of that contact.

If both are true, then return the "value" of that property.

If name does not correspond to any contacts then return the string No such contact.

If prop does not correspond to any valid properties of a contact found to match name then return the string No such property.
Tests

Passed: lookUpProfile("Kristian", "lastName") should return the string Vos
Passed: lookUpProfile("Sherlock", "likes") should return ["Intriguing Cases", "Violin"]
Passed: lookUpProfile("Harry", "likes") should return an array
Passed: lookUpProfile("Bob", "number") should return the string No such contact
Passed: lookUpProfile("Bob", "potato") should return the string No such contact
Passed: lookUpProfile("Akira", "address") should return the string No such property*/ 

// Setup
const contacts = [
  {
    firstName: "Akira",
    lastName: "Laine",
    number: "0543236543",
    likes: ["Pizza", "Coding", "Brownie Points"],
  },
  {
    firstName: "Harry",
    lastName: "Potter",
    number: "0994372684",
    likes: ["Hogwarts", "Magic", "Hagrid"],
  },
  {
    firstName: "Sherlock",
    lastName: "Holmes",
    number: "0487345643",
    likes: ["Intriguing Cases", "Violin"],
  },
  {
    firstName: "Kristian",
    lastName: "Vos",
    number: "unknown",
    likes: ["JavaScript", "Gaming", "Foxes"],
  },
];

function lookUpProfile(name, prop) {
  // Only change code below this line
for (let i = 0; i < contacts.length; i++){
  if (contacts[i].firstName === name){
    if (contacts[i].hasOwnProperty(prop)){
    return contacts[i][prop];
  } else {
    return "No such property";
          }
    }
}
  return "No such contact";

  // Only change code above this line
}
lookUpProfile("Akira", "likes");

// also (sugg sln)
function lookUpProfile(name, prop){
  for (var i = 0; i < contacts.length; i++) {
    if(contacts[i].firstName === name) {
      return contacts[i][prop] || "No such property";
    }
  }
  return "No such contact";
}
// a shorter form of doing this without having to check for contact's property, return it instead


/*
    Use Recursion to Create a Countdown

In a previous challenge, you learned how to use recursion to replace a for loop. Now, let's look at a more complex function that returns an array of consecutive integers starting with 1 through the number passed to the function.

As mentioned in the previous challenge, there will be a base case. The base case tells the recursive function when it no longer needs to call itself. It is a simple case where the return value is already known. There will also be a recursive call which executes the original function with different arguments. If the function is written correctly, eventually the base case will be reached.

For example, say you want to write a recursive function that returns an array containing the numbers 1 through n. This function will need to accept an argument, n, representing the final number. Then it will need to call itself with progressively smaller values of n until it reaches 1. You could write the function as follows:

function countup(n) {
  if (n < 1) {
    return [];
  } else {
    const countArray = countup(n - 1);
    countArray.push(n);
    return countArray;
  }
}
console.log(countup(5));

The value [1, 2, 3, 4, 5] will be displayed in the console.

At first, this seems counterintuitive since the value of n decreases, but the values in the final array are increasing. This happens because the push happens last, after the recursive call has returned. At the point where n is pushed into the array, countup(n - 1) has already been evaluated and returned [1, 2, ..., n - 1].

We have defined a function called countdown with one parameter (n). The function should use recursion to return an array containing the integers n through 1 based on the n parameter. If the function is called with a number less than 1, the function should return an empty array. For example, calling this function with n = 5 should return the array [5, 4, 3, 2, 1]. Your function must use recursion by calling itself and must not use loops of any kind.
Tests

Passed: countdown(-1) should return an empty array.
Passed: countdown(10) should return [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Passed: countdown(5) should return [5, 4, 3, 2, 1]
Passed: Your code should not rely on any kind of loops (for, while or higher order functions such as forEach, map, filter, and reduce).
Passed: You should use recursion to solve this problem.
Passed: Global variables should not be used to cache the array.
*/
// Only change code below this line
function countdown(n){
  if (n < 1){
  return [];
  } else {
    const countArr = countdown(n - 1);
    countArr.unshift(n);
    return countArr;
   }
}
// Only change code above this line


/*
    Use Recursion to Create a Range of Numbers

Continuing from the previous challenge, we provide you another opportunity to create a recursive function to solve a problem.

We have defined a function named rangeOfNumbers with two parameters. The function should return an array of integers which begins with a number represented by the startNum parameter and ends with a number represented by the endNum parameter. The starting number will always be less than or equal to the ending number. Your function must use recursion by calling itself and not use loops of any kind. It should also work for cases where both startNum and endNum are the same.
Tests

Waiting: Your function should return an array.
Waiting: Your code should not use any loop syntax (for or while or higher order functions such as forEach, map, filter, or reduce).
Waiting: rangeOfNumbers should use recursion (call itself) to solve this challenge.
Waiting: rangeOfNumbers(1, 5) should return [1, 2, 3, 4, 5].
Waiting: rangeOfNumbers(6, 9) should return [6, 7, 8, 9].
Waiting: rangeOfNumbers(4, 4) should return [4].
Waiting: Global variables should not be used to cache the array.*/ 
function rangeOfNumbers(startNum, endNum) {
  if (endNum < startNum) {
    return [];
  } else {
    const numbers = rangeOfNumbers(startNum, endNum - 1);
    numbers.push(endNum);
    return numbers;
  }
}

/*
    Use the Rest Parameter with Function Parameters

In order to help us create more flexible functions, ES6 introduces the rest parameter for function parameters. With the rest parameter, you can create functions that take a variable number of arguments. These arguments are stored in an array that can be accessed later from inside the function.

Check out this code:

function howMany(...args) {
  return "You have passed " + args.length + " arguments.";
}
console.log(howMany(0, 1, 2));
console.log(howMany("string", null, [1, 2, 3], { }));

The console would display the strings You have passed 3 arguments. and You have passed 4 arguments..

The rest parameter eliminates the need to check the args array and allows us to apply map(), filter() and reduce() on the parameters array.

Modify the function sum using the rest parameter in such a way that the function sum is able to take any number of arguments and return their sum.
Tests

Passed: The result of sum(0,1,2) should be 3
Passed: The result of sum(1,2,3,4) should be 10
Passed: The result of sum(5) should be 5
Passed: The result of sum() should be 0
Passed: sum should be an arrow function which uses the rest parameter syntax (...) on the args parameter.*/ 

const sum = (...args) => {
  return args.reduce((a, b) => a + b, 0);
}
    

/*
Destructuring via rest elements

In some situations involving array destructuring, we might want to collect the rest of the elements into a separate array.

The result is similar to Array.prototype.slice(), as shown below:

const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];
console.log(a, b);
console.log(arr);

The console would display the values 1, 2 and [3, 4, 5, 7].

Variables a and b take the first and second values from the array. After that, because of the rest syntax presence, arr gets the rest of the values in the form of an array. The rest element only works correctly as the last variable in the list. As in, you cannot use the rest syntax to catch a subarray that leaves out the last element of the original array.

Use a destructuring assignment with the rest syntax to emulate the behavior of Array.prototype.slice(). removeFirstTwo() should return a sub-array of the original array list with the first two elements omitted.
Tests

Passed: removeFirstTwo([1, 2, 3, 4, 5]) should be [3, 4, 5]
Passed: removeFirstTwo() should not modify list
Passed: Array.slice() should not be used.
Passed: Destructuring on list should be used.
*/ 
function removeFirstTwo(list) {
  // Only change code below this line
  // const shorterList = list; // Change this line
  const [a, b, ...shorterList] = list; 
  // Only change code above this line
  console.log( shorterList);
  console.log(a, b)
  return shorterList;
}

const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const sourceWithoutFirstTwo = removeFirstTwo(source);

/*
Create Strings using Template Literals

A new feature of ES6 is the template literal. This is a special type of string that makes creating complex strings easier.

Template literals allow you to create multi-line strings and to use string interpolation features to create strings.

Consider the code below:

const person = {
  name: "Zodiac Hasbro",
  age: 56
};

const greeting = `Hello, my name is ${person.name}!
I am ${person.age} years old.`;

console.log(greeting);

The console will display the strings Hello, my name is Zodiac Hasbro! and I am 56 years old..

A lot of things happened there. Firstly, the example uses backticks (`), not quotes (' or "), to wrap the string. Secondly, notice that the string is multi-line, both in the code and the output. This saves inserting \n within strings. The ${variable} syntax used above is a placeholder. Basically, you won't have to use concatenation with the + operator anymore. To add variables to strings, you just drop the variable in a template string and wrap it with ${ and }. Similarly, you can include other expressions in your string literal, for example ${a + b}. This new way of creating strings gives you more flexibility to create robust strings.

Use template literal syntax with backticks to create an array of list element (li) strings. Each list element's text should be one of the array elements from the failure property on the result object and have a class attribute with the value text-warning. The makeList function should return the array of list item strings.

Use an iterator method (any kind of loop) to get the desired output (shown below).

[
  '<li class="text-warning">no-var</li>',
  '<li class="text-warning">var-on-top</li>',
  '<li class="text-warning">linebreak</li>'
]

Tests

Passed: failuresList should be an array containing result failure messages.
Passed: failuresList should be equal to the specified output.
Passed: Template strings and expression interpolation should be used.
Passed: An iterator should be used.
*/

const result = {
  success: ["max-length", "no-amd", "prefer-arrow-functions"],
  failure: ["no-var", "var-on-top", "linebreak"],
  skipped: ["no-extra-semi", "no-dup-keys"]
};
function makeList(arr) {
  // Only change code below this line
  let failureItems = [];
  for (let i=0;i<arr.length;i++){
    failureItems.push(`<li class="text-warning">${result.failure[i]}</li>`)
  }
  // Only change code above this line

  return failureItems;
}

const failureList = makeList(result.failure);

// also with  .map()
const results = {
  success: ["max-length", "no-amd", "prefer-arrow-functions"],
  failure: ["no-var", "var-on-top", "linebreak"],
  skipped: ["no-extra-semi", "no-dup-keys"]
};
function makeList(arr) {
  "use strict";
  // change code below this line
  const failureItems = arr.map(item => `<li class="text-warning">${item}</li>`);
  // change code above this line
  return failureItems;
}
const failuresList = makeList(results.failure);




/*
Use class Syntax to Define a Constructor Function

ES6 provides a new syntax to create objects, using the class keyword.

It should be noted that the class syntax is just syntax, and not a full-fledged class-based implementation of an object-oriented paradigm, unlike in languages such as Java, Python, Ruby, etc.

In ES5, an object can be created by defining a constructor function and using the new keyword to instantiate the object.

In ES6, a class declaration has a constructor method that is invoked with the new keyword. If the constructor method is not explicitly defined, then it is implicitly defined with no arguments.

// Explicit constructor
class SpaceShuttle {
  constructor(targetPlanet) {
    this.targetPlanet = targetPlanet;
  }
  takeOff() {
    console.log("To " + this.targetPlanet + "!");
  }
}

// Implicit constructor 
class Rocket {
  launch() {
    console.log("To the moon!");
  }
}

const zeus = new SpaceShuttle('Jupiter');
// prints To Jupiter! in console
zeus.takeOff();

const atlas = new Rocket();
// prints To the moon! in console
atlas.launch();

It should be noted that the class keyword declares a new function, to which a constructor is added. This constructor is invoked when new is called to create a new object.

Note: UpperCamelCase should be used by convention for ES6 class names, as in SpaceShuttle used above.

The constructor method is a special method for creating and initializing an object created with a class. You will learn more about it in the Object Oriented Programming section of the JavaScript Algorithms And Data Structures Certification.

Use the class keyword and write a constructor to create the Vegetable class.

The Vegetable class allows you to create a vegetable object with a property name that gets passed to the constructor.
Tests

Passed: Vegetable should be a class with a defined constructor method.
Passed: The class keyword should be used.
Passed: Vegetable should be able to be instantiated.
Passed: carrot.name should return carrot.
*/ 

// Only change code below this line
class Vegetable{
  constructor (name){
    this.name = name;
  }
}

// Only change code above this line

const carrot = new Vegetable("carrot");
// carrot.name()
console.log(carrot.name); // Should display 'carrot'

// the sln wasn't quite what I expected given the examples
// also ES6 didn't work


/*
Use getters and setters to Control Access to an Object

You can obtain values from an object and set the value of a property within an object.

These are classically called getters and setters.

Getter functions are meant to simply return (get) the value of an object's private variable to the user without the user directly accessing the private variable.

Setter functions are meant to modify (set) the value of an object's private variable based on the value passed into the setter function. This change could involve calculations, or even overwriting the previous value completely.

class Book {
  constructor(author) {
    this._author = author;
  }
  // getter
  get writer() {
    return this._author;
  }
  // setter
  set writer(updatedAuthor) {
    this._author = updatedAuthor;
  }
}
const novel = new Book('anonymous');
console.log(novel.writer);
novel.writer = 'newAuthor';
console.log(novel.writer);

The console would display the strings anonymous and newAuthor.

Notice the syntax used to invoke the getter and setter. They do not even look like functions. Getters and setters are important because they hide internal implementation details.

Note: It is convention to precede the name of a private variable with an underscore (_). However, the practice itself does not make a variable private.

Use the class keyword to create a Thermostat class. The constructor accepts a Fahrenheit temperature.

In the class, create a getter to obtain the temperature in Celsius and a setter to set the temperature in Celsius.

Remember that C = 5/9 * (F - 32) and F = C * 9.0 / 5 + 32, where F is the value of temperature in Fahrenheit, and C is the value of the same temperature in Celsius.

Note: When you implement this, you will track the temperature inside the class in one scale, either Fahrenheit or Celsius.

This is the power of a getter and a setter. You are creating an API for another user, who can get the correct result regardless of which one you track.

In other words, you are abstracting implementation details from the user.
Tests

Passed: Thermostat should be a class with a defined constructor method.
Passed: class keyword should be used.
Passed: Thermostat should be able to be instantiated.
Passed: When instantiated with a Fahrenheit value, Thermostat should set the correct temperature.
Passed: A getter should be defined.
Passed: A setter should be defined.
Passed: Calling the setter with a Celsius value should set the temperature.
*/ 

// Only change code below this line
class Thermostat{
  constructor(fahrenheit){
    this.fahrenheit = fahrenheit; 
  }
  // getter
  get temperature(){
    return 5/9 * (this.fahrenheit - 32)
  }
  // setter
  set temperature(celcius){
  this.fahrenheit = celcius * 9.0/5 + 32;
  }
}
// Only change code above this line

const thermos = new Thermostat(76); // Setting in Fahrenheit scale
let temp = thermos.temperature; // 24.44 in Celsius
thermos.temperature = 26;
temp = thermos.temperature; // 26 in Celsius


/*
Complete a Promise with resolve and reject

A promise has three states: pending, fulfilled, and rejected. The promise you created in the last challenge is forever stuck in the pending state because you did not add a way to complete the promise. The resolve and reject parameters given to the promise argument are used to do this. resolve is used when you want your promise to succeed, and reject is used when you want it to fail. These are methods that take an argument, as seen below.

const myPromise = new Promise((resolve, reject) => {
  if(condition here) {
    resolve("Promise was fulfilled");
  } else {
    reject("Promise was rejected");
  }
});

The example above uses strings for the argument of these functions, but it can really be anything. Often, it might be an object, that you would use data from, to put on your website or elsewhere.

Make the promise handle success and failure. If responseFromServer is true, call the resolve method to successfully complete the promise. Pass resolve a string with the value We got the data. If responseFromServer is false, use the reject method instead and pass it the string: Data not received.
Tests

Passed: resolve should be called with the expected string when the if condition is true.
Passed: reject should be called with the expected string when the if condition is false.
*/ 

const makeServerRequest = new Promise((resolve, reject) => {
  // responseFromServer represents a response from a server
  let responseFromServer;
    
  if(responseFromServer) {
    resolve ("We got the data");
  } else {  
    reject ("Data not received");
  }
});


/*
Match Anything with Wildcard Period

Sometimes you won't (or don't need to) know the exact characters in your patterns. Thinking of all words that match, say, a misspelling would take a long time. Luckily, you can save time using the wildcard character: .

The wildcard character . will match any one character. The wildcard is also called dot and period. You can use the wildcard character just like any other character in the regex. For example, if you wanted to match hug, huh, hut, and hum, you can use the regex /hu./ to match all four words.

let humStr = "I'll hum a song";
let hugStr = "Bear hug";
let huRegex = /hu./;
huRegex.test(humStr);
huRegex.test(hugStr);

Both of these test calls would return true.

Complete the regex unRegex so that it matches the strings run, sun, fun, pun, nun, and bun. Your regex should use the wildcard character.
Tests

Passed: You should use the .test() method.
Passed: You should use the wildcard character in your regex unRegex
Passed: Your regex unRegex should match run in the string Let us go on a run.
Passed: Your regex unRegex should match sun in the string The sun is out today.
Passed: Your regex unRegex should match fun in the string Coding is a lot of fun.
Passed: Your regex unRegex should match pun in the string Seven days without a pun makes one weak.
Passed: Your regex unRegex should match nun in the string One takes a vow to be a nun.
Passed: Your regex unRegex should match bun in the string She got fired from the hot dog stand for putting her hair in a bun.
Passed: Your regex unRegex should not match the string There is a bug in my code.
Passed: Your regex unRegex should not match the string Catch me if you can.
*/ 

let exampleStr = "Let's have fun with regular expressions!";
let unRegex = /.un/; // Change this line
let res = unRegex.test(exampleStr);

/*
Positive and Negative Lookahead

Lookaheads are patterns that tell JavaScript to look-ahead in your string to check for patterns further along. This can be useful when you want to search for multiple patterns over the same string.

There are two kinds of lookaheads: positive lookahead and negative lookahead.

A positive lookahead will look to make sure the element in the search pattern is there, but won't actually match it. A positive lookahead is used as (?=...) where the ... is the required part that is not matched.

On the other hand, a negative lookahead will look to make sure the element in the search pattern is not there. A negative lookahead is used as (?!...) where the ... is the pattern that you do not want to be there. The rest of the pattern is returned if the negative lookahead part is not present.

Lookaheads are a bit confusing but some examples will help.

let quit = "qu";
let noquit = "qt";
let quRegex= /q(?=u)/;
let qRegex = /q(?!u)/;
quit.match(quRegex);
noquit.match(qRegex);

Both of these match calls would return ["q"].

A more practical use of lookaheads is to check two or more patterns in one string. Here is a (naively) simple password checker that looks for between 3 and 6 characters and at least one number:

let password = "abc123";
let checkPass = /(?=\w{3,6})(?=\D*\d)/;
checkPass.test(password);

Use lookaheads in the pwRegex to match passwords that are greater than 5 characters long, and have two consecutive digits.
Tests

Passed: Your regex should use two positive lookaheads.
Passed: Your regex should not match the string astronaut
Passed: Your regex should not match the string banan1
Passed: Your regex should match the string bana12
Passed: Your regex should match the string abc123
Passed: Your regex should not match the string 12345
Passed: Your regex should match the string 8pass99
Passed: Your regex should not match the string 1a2bcde
Passed: Your regex should match the string astr1on11aut
*/
let sampleWord = "astronaut";
let pwRegex = /(?=\w{6,})(?=\D*\d{2})/; // Change this line
let resu = pwRegex.test(sampleWord); 




/*
Use Capture Groups to Search and Replace

Searching is useful. However, you can make searching even more powerful when it also changes (or replaces) the text you match.

You can search and replace text in a string using .replace() on a string. The inputs for .replace() is first the regex pattern you want to search for. The second parameter is the string to replace the match or a function to do something.

let wrongText = "The sky is silver.";
let silverRegex = /silver/;
wrongText.replace(silverRegex, "blue");

The replace call would return the string The sky is blue..

You can also access capture groups in the replacement string with dollar signs ($).

"Code Camp".replace(/(\w+)\s(\w+)/, '$2 $1');

The replace call would return the string Camp Code.

Write a regex fixRegex using three capture groups that will search for each word in the string one two three. Then update the replaceText variable to replace one two three with the string three two one and assign the result to the result variable. Make sure you are utilizing capture groups in the replacement string using the dollar sign ($) syntax.
Tests

Passed: You should use .replace() to search and replace.
Passed: Your regex should change the string one two three to the string three two one
Passed: You should not change the last line.
Passed: fixRegex should use at least three capture groups.
Passed: replaceText should use parenthesized submatch string(s) (i.e. the nth parenthesized submatch string, $n, corresponds to the nth capture group).
*/ 

let str = "one two three";
let fixRegex = /(\w+)\s(\w+)\s(\w+)/; // Change this line
let replaceText = ("$3 $2 $1"); // Change this line
let resul = str.replace(fixRegex, replaceText);

// let result = "one two three".replace( /(\w+)\s(\w+)\s(\w+)/, '$3 $2 $1');


/*
Copy an Array with the Spread Operator

While slice() allows us to be selective about what elements of an array to copy, among several other useful tasks, ES6's new spread operator allows us to easily copy all of an array's elements, in order, with a simple and highly readable syntax. The spread syntax simply looks like this: ...

In practice, we can use the spread operator to copy an array like so:

let thisArray = [true, true, undefined, false, null];
let thatArray = [...thisArray];

thatArray equals [true, true, undefined, false, null]. thisArray remains unchanged and thatArray contains the same elements as thisArray.

We have defined a function, copyMachine which takes arr (an array) and num (a number) as arguments. The function is supposed to return a new array made up of num copies of arr. We have done most of the work for you, but it doesn't work quite right yet. Modify the function using spread syntax so that it works correctly (hint: another method we have already covered might come in handy here!).
Tests

Passed: copyMachine([true, false, true], 2) should return [[true, false, true], [true, false, true]]
Passed: copyMachine([1, 2, 3], 5) should return [[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]
Passed: copyMachine([true, true, null], 1) should return [[true, true, null]]
Passed: copyMachine(["it works"], 3) should return [["it works"], ["it works"], ["it works"]]
Passed: The copyMachine function should utilize the spread operator with array arr
*/ 

function copyMachine(arr, num) {
  let newArr = [];
  while (num >= 1) {
    // Only change code below this line
    newArr.push([...arr])
    // Only change code above this line
    num--;
  }
  return newArr;
}

console.log(copyMachine([true, false, true], 2));

</script>
</body>
</html>