<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Code Camp</title>
</head>
<body>
    <script>
    /*
    
    
    In the game of Golf, each hole has a par, meaning, the average number of strokes a golfer is expected to make in order to sink the ball in the hole to complete the play. Depending on how far above or below par your strokes are, there is a different nickname.
    
    Your function will be passed par and strokes arguments. Return the correct string according to this table which lists the strokes in order of priority; top (highest) to bottom (lowest):
    Strokes	Return
    1	"Hole-in-one!"
    <= par - 2	"Eagle"
    par - 1	"Birdie"
    par	"Par"
    par + 1	"Bogey"
    par + 2	"Double Bogey"
    >= par + 3	"Go Home!"
    
    par and strokes will always be numeric and positive. We have added an array of all the names for your convenience.
    
    */
    const names = ["Hole-in-one!", "Eagle", "Birdie", "Par", "Bogey", "Double Bogey", "Go Home!"];

function golfScore(par, strokes) {
  // Only change code below this line
if (strokes == 1){
  return names[0]
}else if (strokes <= par - 2){
  return names[1]
}else if (strokes == par - 1){
  return names[2]
}else if (strokes == par){
  return names[3]
}else if (strokes == par + 1){
  return names[4]
}else if (strokes == par + 2){
  return names[5]
}else if (strokes >= par + 3){
  return names[6]
}
  return "Change Me";
  // Only change code above this line
}

golfScore(5, 4);





/*
In a switch statement you may not be able to specify all possible values as case statements. Instead, you can add the default statement which will be executed if no matching case statements are found. Think of it like the final else statement in an if/else chain.

A default statement should be the last case.

switch (num) {
  case value1:
    statement1;
    break;
  case value2:
    statement2;
    break;
...
  default:
    defaultStatement;
    break;
}

Write a switch statement to set answer for the following conditions:
a - apple
b - bird
c - cat
default - stuff
*/ 
function switchOfStuff(val) {
  let answer = "";
  // Only change code below this line
switch (val){
  case "a": 
    answer = "apple";
    break;
  case "b": 
    answer = "bird";
    break;
  case "c": 
    answer = "cat";
    break;
  default: 
    answer = "stuff";
    break;
}
  // Only change code above this line
  return answer;
}

switchOfStuff(1);


/*
Multiple Identical Options in Switch Statements

If the break statement is omitted from a switch statement's case, the following case statement(s) are executed until a break is encountered. If you have multiple inputs with the same output, you can represent them in a switch statement like this:

let result = "";
switch (val) {
  case 1:
  case 2:
  case 3:
    result = "1, 2, or 3";
    break;
  case 4:
    result = "4 alone";
}

Cases for 1, 2, and 3 will all produce the same result.

Write a switch statement to set answer for the following ranges:
1-3 - Low
4-6 - Mid
7-9 - High

Note: You will need to have a case statement for each number in the range.
*/ 

function sequentialSizes(val) {
  let answer = "";
  // Only change code below this line
switch (val){
  case 1:
  case 2:
  case 3:
    answer = "Low"
    break;
  case 4:
  case 5: 
  case 6:
    answer = "Mid"
    break;
  case 7:
  case 8:
  case 9:
    answer = "High" 
}
  // Only change code above this line
  return answer;
}

sequentialSizes(1);

/*
 Counting Cards

In the casino game Blackjack, a player can determine whether they have an advantage on the next hand over the house by keeping track of the relative number of high and low cards remaining in the deck. This is called Card Counting.

Having more high cards remaining in the deck favors the player. Each card is assigned a value according to the table below. When the count is positive, the player should bet high. When the count is zero or negative, the player should bet low.
Count Change	Cards
+1	2, 3, 4, 5, 6
0	7, 8, 9
-1	10, 'J', 'Q', 'K', 'A'

You will write a card counting function. It will receive a card parameter, which can be a number or a string, and increment or decrement the global count variable according to the card's value (see table). The function will then return a string with the current count and the string Bet if the count is positive, or Hold if the count is zero or negative. The current count and the player's decision (Bet or Hold) should be separated by a single space.

Example Outputs: -3 Hold or 5 Bet

Hint
Do NOT reset count to 0 when value is 7, 8, or 9.
Do NOT return an array.
Do NOT include quotes (single or double) in the output.
Tests

Passed: Your function should return a value for count and the text (Bet or Hold) with one space character between them.
Passed: Cards Sequence 2, 3, 4, 5, 6 should return the string 5 Bet
Passed: Cards Sequence 7, 8, 9 should return the string 0 Hold
Passed: Cards Sequence 10, J, Q, K, A should return the string -5 Hold
Passed: Cards Sequence 3, 7, Q, 8, A should return the string -1 Hold
Passed: Cards Sequence 2, J, 9, 2, 7 should return the string 1 Bet
Passed: Cards Sequence 2, 2, 10 should return the string 1 Bet
Passed: Cards Sequence 3, 2, A, 10, K should return the string -1 Hold
 */
 
 let count = 0;

function cc(card) {
  // Only change code below this line
switch (card){
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
    count++;
    break;
    // these lines below are not needed 
  // case 7: 
  // case 8: 
  // case 9: 
  //   break;
  case 10: 
  case "J": 
  case "Q":
  case "K": 
  case "A": 
    count--;
    break;
}
  if (count > 0 ){
    return (`${count} Bet`);
  } else if(count < 0){
    return (`${count} Hold`);
  } else {
    console.log(count)
    return (`${count} Hold`); 
  };
  // Only change code above this line
}

// sugested sln 
let counts = 0;
function cc(card) {
  if (card <= 6) 
    counts++;
  else if (card >="10")
//   here type coersion is turning a "string" to a number and also b/c numbers come before letters in a dictionary letters are larger thus "K" > "10" returns true also "B" > "A" so "Z" is larger than the rest of them
    counts--;
  return counts + (counts > 0 ? ' Bet' : ' Hold');
}
// cc(2); cc(3); cc(7); cc('K');  cc('A');




/*
You are given an object literal representing a part of your musical album collection. Each album has a unique id number as its key and several other properties. Not all albums have complete information.

You start with an updateRecords function that takes an object literal, records, containing the musical album collection, an id, a prop (like artist or tracks), and a value. Complete the function using the rules below to modify the object passed to the function.

   Your function must always return the entire record collection object.
   If prop isn't tracks and value isn't an empty string, update or set that album's prop to value.
   If prop is tracks but the album doesn't have a tracks property, create an empty array and add value to it.
   If prop is tracks and value isn't an empty string, add value to the end of the album's existing tracks array.
   If value is an empty string, delete the given prop property from the album.

Note: A copy of the recordCollection object is used for the tests.
Tests

Passed: After updateRecords(recordCollection, 5439, "artist", "ABBA"), artist should be the string ABBA
Passed: After updateRecords(recordCollection, 5439, "tracks", "Take a Chance on Me"), tracks should have the string Take a Chance on Me as the last and only element.
Passed: After updateRecords(recordCollection, 2548, "artist", ""), artist should not be set
Passed: After updateRecords(recordCollection, 1245, "tracks", "Addicted to Love"), tracks should have the string Addicted to Love as the last element.
Passed: After updateRecords(recordCollection, 2468, "tracks", "Free"), tracks should have the string 1999 as the first element.
Passed: After updateRecords(recordCollection, 2548, "tracks", ""), tracks should not be set
Passed: After updateRecords(recordCollection, 1245, "albumTitle", "Riptide"), albumTitle should be the string Riptide
*/
// Setup
const recordCollection = {
  2548: { //id
    albumTitle: 'Slippery When Wet', // prop : value
    artist: 'Bon Jovi',
    tracks: ['Let It Rock', 'You Give Love a Bad Name']
  },
  2468: {
    albumTitle: '1999',
    artist: 'Prince',
    tracks: ['1999', 'Little Red Corvette']
  },
  1245: {
    artist: 'Robert Palmer',
    tracks: []
  },
  5439: {
    albumTitle: 'ABBA Gold'
  }
};

// Only change code below this line
function updateRecords(records, id, prop, value) {
  if (prop !== 'tracks' && value !== "") {
    records[id][prop] = value;
  } else if (prop === "tracks" && records[id].hasOwnProperty("tracks") === false){
    records[id][prop] = [value];
  } else if (prop === "tracks" && value !== "") {
    records[id][prop].push(value);
  } else if (value === "") {
    delete records[id][prop];
  }
  return records;
}


updateRecords(recordCollection, 5439, 'artist', 'ABBA');


/*
Replace Loops using Recursion

Recursion is the concept that a function can be expressed in terms of itself. To help understand this, start by thinking about the following task: multiply the first n elements of an array to create the product of those elements. Using a for loop, you could do this:

  function multiply(arr, n) {
    let product = 1;
    for (let i = 0; i < n; i++) {
      product *= arr[i];
    }
    return product;
  }

However, notice that multiply(arr, n) == multiply(arr, n - 1) * arr[n - 1]. That means you can rewrite multiply in terms of itself and never need to use a loop.

  function multiply(arr, n) {
    if (n <= 0) {
      return 1;
    } else {
      return multiply(arr, n - 1) * arr[n - 1];
    }
  }

The recursive version of multiply breaks down like this. In the base case, where n <= 0, it returns 1. For larger values of n, it calls itself, but with n - 1. That function call is evaluated in the same way, calling multiply again until n <= 0. At this point, all the functions can return and the original multiply returns the answer.

Note: Recursive functions must have a base case when they return without calling the function again (in this example, when n <= 0), otherwise they can never finish executing.

Write a recursive function, sum(arr, n), that returns the sum of the first n elements of an array arr.
Tests

Passed: sum([1], 0) should equal 0.
Passed: sum([2, 3, 4], 1) should equal 2.
Passed: sum([2, 3, 4, 5], 3) should equal 9.
Passed: Your code should not rely on any kind of loops (for or while or higher order functions such as forEach, map, filter, or reduce.).
Passed: You should use recursion to solve this problem.
*/ 
function sum(arr, n) {
  // Only change code below this line
  let total = 0;
if (n <= 0){
  return total;
} else {
  return sum(arr, n - 1) + arr[n-1];
}
  // Only change code above this line
}




/*
Profile Lookup

We have an array of objects representing different people in our contacts lists.

A lookUpProfile function that takes name and a property (prop) as arguments has been pre-written for you.

The function should check if name is an actual contact's firstName and the given property (prop) is a property of that contact.

If both are true, then return the "value" of that property.

If name does not correspond to any contacts then return the string No such contact.

If prop does not correspond to any valid properties of a contact found to match name then return the string No such property.
Tests

Passed: lookUpProfile("Kristian", "lastName") should return the string Vos
Passed: lookUpProfile("Sherlock", "likes") should return ["Intriguing Cases", "Violin"]
Passed: lookUpProfile("Harry", "likes") should return an array
Passed: lookUpProfile("Bob", "number") should return the string No such contact
Passed: lookUpProfile("Bob", "potato") should return the string No such contact
Passed: lookUpProfile("Akira", "address") should return the string No such property*/ 

// Setup
const contacts = [
  {
    firstName: "Akira",
    lastName: "Laine",
    number: "0543236543",
    likes: ["Pizza", "Coding", "Brownie Points"],
  },
  {
    firstName: "Harry",
    lastName: "Potter",
    number: "0994372684",
    likes: ["Hogwarts", "Magic", "Hagrid"],
  },
  {
    firstName: "Sherlock",
    lastName: "Holmes",
    number: "0487345643",
    likes: ["Intriguing Cases", "Violin"],
  },
  {
    firstName: "Kristian",
    lastName: "Vos",
    number: "unknown",
    likes: ["JavaScript", "Gaming", "Foxes"],
  },
];

function lookUpProfile(name, prop) {
  // Only change code below this line
for (let i = 0; i < contacts.length; i++){
  if (contacts[i].firstName === name){
    if (contacts[i].hasOwnProperty(prop)){
    return contacts[i][prop];
  } else {
    return "No such property";
          }
    }
}
  return "No such contact";

  // Only change code above this line
}
lookUpProfile("Akira", "likes");

// also (sugg sln)
function lookUpProfile(name, prop){
  for (var i = 0; i < contacts.length; i++) {
    if(contacts[i].firstName === name) {
      return contacts[i][prop] || "No such property";
    }
  }
  return "No such contact";
}
// a shorter form of doing this without having to check for contact's property, return it instead


/*
    Use Recursion to Create a Countdown

In a previous challenge, you learned how to use recursion to replace a for loop. Now, let's look at a more complex function that returns an array of consecutive integers starting with 1 through the number passed to the function.

As mentioned in the previous challenge, there will be a base case. The base case tells the recursive function when it no longer needs to call itself. It is a simple case where the return value is already known. There will also be a recursive call which executes the original function with different arguments. If the function is written correctly, eventually the base case will be reached.

For example, say you want to write a recursive function that returns an array containing the numbers 1 through n. This function will need to accept an argument, n, representing the final number. Then it will need to call itself with progressively smaller values of n until it reaches 1. You could write the function as follows:

function countup(n) {
  if (n < 1) {
    return [];
  } else {
    const countArray = countup(n - 1);
    countArray.push(n);
    return countArray;
  }
}
console.log(countup(5));

The value [1, 2, 3, 4, 5] will be displayed in the console.

At first, this seems counterintuitive since the value of n decreases, but the values in the final array are increasing. This happens because the push happens last, after the recursive call has returned. At the point where n is pushed into the array, countup(n - 1) has already been evaluated and returned [1, 2, ..., n - 1].

We have defined a function called countdown with one parameter (n). The function should use recursion to return an array containing the integers n through 1 based on the n parameter. If the function is called with a number less than 1, the function should return an empty array. For example, calling this function with n = 5 should return the array [5, 4, 3, 2, 1]. Your function must use recursion by calling itself and must not use loops of any kind.
Tests

Passed: countdown(-1) should return an empty array.
Passed: countdown(10) should return [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Passed: countdown(5) should return [5, 4, 3, 2, 1]
Passed: Your code should not rely on any kind of loops (for, while or higher order functions such as forEach, map, filter, and reduce).
Passed: You should use recursion to solve this problem.
Passed: Global variables should not be used to cache the array.
*/
// Only change code below this line
function countdown(n){
  if (n < 1){
  return [];
  } else {
    const countArr = countdown(n - 1);
    countArr.unshift(n);
    return countArr;
   }
}
// Only change code above this line


/*
    Use Recursion to Create a Range of Numbers

Continuing from the previous challenge, we provide you another opportunity to create a recursive function to solve a problem.

We have defined a function named rangeOfNumbers with two parameters. The function should return an array of integers which begins with a number represented by the startNum parameter and ends with a number represented by the endNum parameter. The starting number will always be less than or equal to the ending number. Your function must use recursion by calling itself and not use loops of any kind. It should also work for cases where both startNum and endNum are the same.
Tests

Waiting: Your function should return an array.
Waiting: Your code should not use any loop syntax (for or while or higher order functions such as forEach, map, filter, or reduce).
Waiting: rangeOfNumbers should use recursion (call itself) to solve this challenge.
Waiting: rangeOfNumbers(1, 5) should return [1, 2, 3, 4, 5].
Waiting: rangeOfNumbers(6, 9) should return [6, 7, 8, 9].
Waiting: rangeOfNumbers(4, 4) should return [4].
Waiting: Global variables should not be used to cache the array.*/ 
function rangeOfNumbers(startNum, endNum) {
  if (endNum < startNum) {
    return [];
  } else {
    const numbers = rangeOfNumbers(startNum, endNum - 1);
    numbers.push(endNum);
    return numbers;
  }
}

/*
    Use the Rest Parameter with Function Parameters

In order to help us create more flexible functions, ES6 introduces the rest parameter for function parameters. With the rest parameter, you can create functions that take a variable number of arguments. These arguments are stored in an array that can be accessed later from inside the function.

Check out this code:

function howMany(...args) {
  return "You have passed " + args.length + " arguments.";
}
console.log(howMany(0, 1, 2));
console.log(howMany("string", null, [1, 2, 3], { }));

The console would display the strings You have passed 3 arguments. and You have passed 4 arguments..

The rest parameter eliminates the need to check the args array and allows us to apply map(), filter() and reduce() on the parameters array.

Modify the function sum using the rest parameter in such a way that the function sum is able to take any number of arguments and return their sum.
Tests

Passed: The result of sum(0,1,2) should be 3
Passed: The result of sum(1,2,3,4) should be 10
Passed: The result of sum(5) should be 5
Passed: The result of sum() should be 0
Passed: sum should be an arrow function which uses the rest parameter syntax (...) on the args parameter.*/ 

const sum = (...args) => {
  return args.reduce((a, b) => a + b, 0);
}
    

/*
Destructuring via rest elements

In some situations involving array destructuring, we might want to collect the rest of the elements into a separate array.

The result is similar to Array.prototype.slice(), as shown below:

const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];
console.log(a, b);
console.log(arr);

The console would display the values 1, 2 and [3, 4, 5, 7].

Variables a and b take the first and second values from the array. After that, because of the rest syntax presence, arr gets the rest of the values in the form of an array. The rest element only works correctly as the last variable in the list. As in, you cannot use the rest syntax to catch a subarray that leaves out the last element of the original array.

Use a destructuring assignment with the rest syntax to emulate the behavior of Array.prototype.slice(). removeFirstTwo() should return a sub-array of the original array list with the first two elements omitted.
Tests

Passed: removeFirstTwo([1, 2, 3, 4, 5]) should be [3, 4, 5]
Passed: removeFirstTwo() should not modify list
Passed: Array.slice() should not be used.
Passed: Destructuring on list should be used.
*/ 
function removeFirstTwo(list) {
  // Only change code below this line
  // const shorterList = list; // Change this line
  const [a, b, ...shorterList] = list; 
  // Only change code above this line
  console.log( shorterList);
  console.log(a, b)
  return shorterList;
}

const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const sourceWithoutFirstTwo = removeFirstTwo(source);

/*
Create Strings using Template Literals

A new feature of ES6 is the template literal. This is a special type of string that makes creating complex strings easier.

Template literals allow you to create multi-line strings and to use string interpolation features to create strings.

Consider the code below:

const person = {
  name: "Zodiac Hasbro",
  age: 56
};

const greeting = `Hello, my name is ${person.name}!
I am ${person.age} years old.`;

console.log(greeting);

The console will display the strings Hello, my name is Zodiac Hasbro! and I am 56 years old..

A lot of things happened there. Firstly, the example uses backticks (`), not quotes (' or "), to wrap the string. Secondly, notice that the string is multi-line, both in the code and the output. This saves inserting \n within strings. The ${variable} syntax used above is a placeholder. Basically, you won't have to use concatenation with the + operator anymore. To add variables to strings, you just drop the variable in a template string and wrap it with ${ and }. Similarly, you can include other expressions in your string literal, for example ${a + b}. This new way of creating strings gives you more flexibility to create robust strings.

Use template literal syntax with backticks to create an array of list element (li) strings. Each list element's text should be one of the array elements from the failure property on the result object and have a class attribute with the value text-warning. The makeList function should return the array of list item strings.

Use an iterator method (any kind of loop) to get the desired output (shown below).

[
  '<li class="text-warning">no-var</li>',
  '<li class="text-warning">var-on-top</li>',
  '<li class="text-warning">linebreak</li>'
]

Tests

Passed: failuresList should be an array containing result failure messages.
Passed: failuresList should be equal to the specified output.
Passed: Template strings and expression interpolation should be used.
Passed: An iterator should be used.
*/

const result = {
  success: ["max-length", "no-amd", "prefer-arrow-functions"],
  failure: ["no-var", "var-on-top", "linebreak"],
  skipped: ["no-extra-semi", "no-dup-keys"]
};
function makeList(arr) {
  // Only change code below this line
  let failureItems = [];
  for (let i=0;i<arr.length;i++){
    failureItems.push(`<li class="text-warning">${result.failure[i]}</li>`)
  }
  // Only change code above this line

  return failureItems;
}

const failuresList = makeList(result.failure);

// also with  .map()
const result = {
  success: ["max-length", "no-amd", "prefer-arrow-functions"],
  failure: ["no-var", "var-on-top", "linebreak"],
  skipped: ["no-extra-semi", "no-dup-keys"]
};
function makeList(arr) {
  "use strict";
  // change code below this line
  const failureItems = arr.map(item => `<li class="text-warning">${item}</li>`);
  // change code above this line
  return failureItems;
}
const failuresList = makeList(result.failure);

</script>
</body>
</html>